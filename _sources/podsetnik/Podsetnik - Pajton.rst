Подсетник - Пајтон
==================

У овој свесци вам дајемо кратак подсетник на основне елементе и
правила рада у Пајтону. Ако сте заборавили како се програмира у овом
програмском језику или сте, из неког разлога, раније пропустили те
лекције, овај подсетник би требало да вам помогне. Као и код било ког
другог програмског језика, најтеже је памтити синтаксу, односно
називе инструкција и правила како се оне комбинују. Овде имате
примере неких основних комбинација.

Типови података
---------------

Пајтон у свом стандардном окружењу, без библиотека, има три основна типа,
односно групе типова података: нумеричке, знаковне и логичке, али у
оквиру њих постоји и финија подела.

Нумерички подаци
~~~~~~~~~~~~~~~~

Пајтон познаје три типа нумеричких, односно бројчаних података:
целобројне вредности (*integer*), децималне бројеве (*float*) и
комплексне бројеве (*complex*). Ког је типа променљива, увек можемо да
проверимо помоћу функције ``type()``.

.. activecode:: integer
    :nocodelens:

    i=10
    print(type(i))
    

Број 10 је свакако цео број, али такође припада и скупу рационалних,
реалних, комплексних бројева итд. Разлог због ког је Пајтон тип ове променљиве
препознао баш као ``int`` је то што бира најекономичнију варијанту. Број
10 ће имати најмањи запис и трошити најмање меморије ако га чувамо као
„синтиџер“. Уколико број има децимални запис (макар из децималне тачке
стајала и нула), тип тог податка ће бити препознат као ``float``.

.. activecode:: float
    :nocodelens:

    f=10.0
    print(type(f))

Пајтон ради и са комплексним бројевима. Имагинарни део комплексног броја
се записује као број иза кога иде слово ј, без размака.

.. activecode:: complex
    :nocodelens:

    c=5j
    print(type(c))


Без обзира на то што Пајтон разликује целе бројеве, реалне и комплексне, он
рачуна са њима заједно.

.. activecode:: mnozenje
    :include: integer, float, complex
    :nocodelens:

    print(i*f*c)

Знаковни подаци
~~~~~~~~~~~~~~~

Знаковне податке обично називамо стринговима или нискама. Одатле ознака
``str``. То су низови алфа-нумеричких карактера записани као текст. Када
променљивој додељујемо вредност која је типа стринг, онда тај податак
стављамо под једноструке или двоструке знаке навода. Битно је да на
почетку и на крају буде иста врста наводника.

.. activecode:: string1
    :nocodelens:

    s='Програмирање у Пајтону'
    print(type(s))


Рачунске операције са стринговима нису исте као са бројевима. Сабирање
стрингова постоји и значи додавање једног низа карактера на други.
Множење два стринга није могуће, али стринг и интиџер могу да се
помноже. Остале комбинације нису могуће. Погледајте примере.

.. activecode:: string2
    :nocodelens:

    a = "Пај"
    b = "тон"
    print(a+b)

.. activecode:: sting3
    :nocodelens:

    a = "тон"
    print(a*8)



Логичке вредности
~~~~~~~~~~~~~~~~~

Тип променљиве која садржи вредност логичког исказа називамо „булеан“
(*boolean*). Булеани имају своје вредности које могу да буду или тачно
(*True*) или нетачно (*False*). Свако поређење вредности променљивих
(било ког типа) помоћу оператора једнако (==), није једнако (!=), мање
(<), веће (>) резултује логичком вредношћу.

.. activecode:: bool1
    :nocodelens:

    a = 5==5.0
    print(a)



.. activecode:: bool2
    :nocodelens:

    print(type(5==5.0))



Операције за рад са логичким вредностима су логичко и (``and`` или
``&``), логичко или (``or`` или ``|``) и не (``not``). Резултати ових
логичких операција су такође логичке вредности.

.. activecode:: bool3
    :nocodelens:

    a = (5==5) & (5!=6)
    print(a)

Осим резултата поређења вредности променљивих, Пајтон „тривијалним“
вредностима нумеричких и знаковних променљивих (нпр. 0, ’’), као и
празним листама, скуповима или речницима придружује логичку вредност
*False*, док свим осталим даје *True*.

.. activecode:: bool4
    :nocodelens:

    a = bool('')
    print(a)

.. activecode:: bool5

    a = bool([False])
    print(a)



Претварање вредности у други тип податка
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

У неким случајевима, тип податка је могуће претворити у други. На пример
стринг „2.75“ лако може да се претвори у реалан број 2.75. Обрнуто
такође важи.

.. activecode:: stringtofloat
    :nocodelens:

    a = float("2.75")
    print(a)

.. activecode:: floattostring
    :nocodelens:

    a = str(1/7)
    print(a)


Претварање интиџера у децимални број је једнозначно, само се промени
формат, а вредност остаје иста. У супротном смеру морамо да занемаримо
цифре иза децималне тачке због чега се вредност променљиве мења.

.. activecode:: inttofloat
    :nocodelens:

    a = float(3)
    print(a)


.. activecode:: floattoint
    :nocodelens:

    a = int(10/3)
    print(a)

Булеане је такође могуће претворити у нумеричке вредности или стрингове.
У супротном смеру, то значи губитак информације и свођење на бинарну
вредност која говори да ли је почетна вредност нетривијална.

.. activecode:: booltostr
    :nocodelens:

    a = str(6>4)
    print(a)



.. activecode:: floattobool
    :nocodelens:

    a = bool(2.5)
    print(a)

Колекције
---------

Пајтон различите типове скупова података назива колекцијама. Постоје
четири основне колекције које имамо на располагању чим покренемо
Пајтон. То су листе, речници, торке и скупови. Ако бисте учитали модул
``collections``, добили бисте још неке, али су нам ове четири које се
подразумевају више него довољне за почетак.

Листе (``list``)
~~~~~~~~~~~~~~~~

Листу правимо тако што унутар угластих заграда наводимо различите
податке раздвајајући их зарезом. Елементи листе могу бити подаци свих
типова па чак и саме листе. Подаци могу да се понављају. Важна
карактеристика листа је да су елементи нумерисани. Сваки елемент има
свој индекс који почиње од нуле. Елементи из листе се позивају преко
имена листе и индекса у угластим заградама.

.. activecode:: lsita
    :nocodelens:

    lista=[2,3,'četiri']
    print(lista[2])  

Речници (``dict``)
~~~~~~~~~~~~~~~~~~

Друга важна колекција су речници. Ту су елементи уређени парови који
увек имају кључ (*key*) и вредност (*value*). Кључ и вредност су
раздвојени двотачком, док су парови раздвојени зарезом унутар
витичастих заграда. Елементи не могу да се понављају и сваки кључ може
да има само једну вредност. Елементи речника нису нумерисани. Уместо
индекса овде користимо кључ за референцирање.

.. activecode:: recnik
    :nocodelens:

    dic={'Земља':'Earth','Месец':'Moon','Сунце':'Sun'}
    print(dic['Месец'])

Торке (``tuple``)
~~~~~~~~~~~~~~~~~

Торке су врло сличне листама. Елементи се углавном набрајају унутар
обичних заграда, али може и без њих. Једина важна разлика у односу на
листе је што вредности елемената, кад су једном дефинисане, не могу више
да се мењају. Ако хоћете другачију торку, направите нову.

.. activecode:: tupple
    :nocodelens:

    torka=(2,3,3,5)
    print(torka[3])

Врло важно својство колекција је да дозвољавају да колекције једне врсте
претварамо у другу. На пример, ако од торке хоћемо да направимо листу,
довољно је да је трансформишемо помоћу функције ``list()``.

.. activecode:: torkaulistu
    :nocodelens:

    torka=(2,3,3,5)
    torka = list(torka)
    print(torka)


Торке имају могућност да већем броју променљивих у једној линији доделе
вредности. Потребно је само да наведемо имена променљивих одвојених
зарезом, онда знак једнако и потом низ вредности које придружујемо
променљивим. Веома је корисна могућност да помоћу торки двема
променљивим заменимо вредности. У другим програмским језицима је за
замену вредности потребно увести и трећу, помоћну променљиву. У Пајтону
је то крајње једноставно: само им заменимо места. Погледајте пример.

.. activecode:: torka_menjanje
    :nocodelens:

    a,b=3,5
    a,b=b,a
    print(a,b)

Скупови (``set``)
~~~~~~~~~~~~~~~~~

Скупови су, као и математички скупови, колекције различитих елемената
који не могу да се понављају. Ове колекције нису нумерисане и не могу се
индексирати. Над скуповима су дефинисане операције које су нам познате
из математике: пресек, унија и разлика.

.. activecode:: set1
    :nocodelens:

    s1={'beli','plavi','crveni','zeleni'}
    s2={'plavi','crni','sivi'}
    unija=s1.union(s2)  # unija prvog i drugog skupa
    presek=s1.intersection(s2) # presek prvog i drugog skupa
    razlika=s1.difference(s2) # razlika prvog i drugog skupa
    print(presek)

Важна особина скупова је то што скупу не можете поново да придружите
елемент који се већ налази у скупу. Нема дупликата. Кад год нам је
потребно да нађемо јединствене елементе неке друге колекције, можемо
помоћу скупа да уклонимо дупликате. На пример, ако узмемо листу у којој
има дупликата, претворимо је у скуп, а потом поново у листу. У тој
другој листи ће остати само јединствене вредности. Погледајте пример.

.. activecode:: lista_set
    :nocodelens:

    lista1=[1,2,2,2,3,4,5,6]
    skup=set(lista1)  # listu pretvaramo u skup kako bismo ukunuli duplikate
    lista2=list(skup) # sad skup vreaćamo u listu
    print(lista2)


Петље
-----

Када део програма треба да поновимо више пута, пожељно је да тај кôд
ставимо у петљу. Петља је програмска структура која нам омогућава да
контролишемо колико ће се пута блок инструкција извршавати. Свако
извршавање кôда у петљи назива се **итерација**. Променљива која броји
колико пута је блок инструкција извршен назива се итератор или
**бројач**.

Најчешће коришћена петља у Пајтону је *for* петља. Ова петља почиње
инструкцијом ``for``, иза које иде услов да се бројач (итератор) налази у
колекцији која следи. Оператор ``in`` између бројача и колекције
означава услов да вредност бројача припада том скупу вредности. Прва
линија петље завршава се две тачке. Следи блок инструкција
који је увучен.

Петља у наредној ћелији је пример једноставног програма који исписује
бројеве од 0 до 9.

.. activecode:: petlja1
    :nocodelens:

    for i in range(10):
        print(i)

Скуп вредности које узима променљива током итерирања овде је био
дефинисан са ``range(10)``, што је распон бројева од 0 до 9. Како у
Пајтону индексирање увек почиње од нуле, вредности ове „итерабле“ иду од
0 до 9. Реч итерабла се односи на све колекције кроз које Пајтон може да
пролази секвенцијално, односно тачно утврђеним редоследом од прве до
последње вредности. Листе су такође итерабле па и њих можемо да
користимо за конструисање петљи. Када итерирамо по колекцији типа
*range*, итератори су бројеви. Ако користимо листу као итераблу, онда су
вредности итератора вредности из листе које редом узимамо.

.. activecode:: lista_stringova
    :nocodelens:

    for s in ['први','други','трећи']:
        print(s)


Итерабле такође могу да буду и скупови, стрингови, торке итд. Стринг
није ништа друго до листа карактера. Зато можемо да итерирамо кроз
стринг, односно да правимо петљу у којој ће итератор узимати вредности
из стринга. Ево једноставног примера:

.. activecode:: petlja_string
    :nocodelens:

    for c in "Python":
        print(c)

Осим *for* петље, Пајтон има и *while* петљу. Код ње није битно да
итератор буде у одређеном скупу. *while* петља се извршава док год је
припадајући услов испуњен, односно док је логички исказ тачан. Ево како пример са *for* петљом можемо да напишемо користећи
инструкцију ``while``.

.. activecode:: while_petlja
    :nocodelens:

    i=0          # početna vrednost iteratora/brojača
    while i<10:  # dok god je brojač manji od 10
        print(i) # štampaj njegovu vrednost
        i+=1     # i povećavaj je za 1


.. suggestionnote::

    Приметите да овде „ручно“ морамо да мењамо вредност индекса ``i``. Израз
    ``i+=1`` је скраћени запис од ``i=i+1``. То значи да у свакој итерацији
    вредност индекса ``i`` повећавамо за 1.

Угњеждене петље
~~~~~~~~~~~~~~~

Унутар једне петље лако можете да ставите другу. Пазите само да
итератори буду различити. Типичан пример проблема који можете да решите
петљом у петљи је да направите табелу где рачунате резултате неке
операције између свака два елемента низа. Конкретно, можемо да направимо
таблицу множења. Потребно је само сваки елемент једног низа помножити са
сваким елементом другог. Следи пример једноставног програма који то
рачуна и исписује на екрану.

.. activecode:: ugnježđene
    :nocodelens:

    n=5
    for i in range(1,n+1):      # za svako i od 1 do 5
        for j in range (1,n+1): # za svako j od 1 do 5
            print(i*j,end="\t") # štampaj i*j i pomeri kurzor za jedan tab
        print("\n")             # kad j dođe do 5 premesti kurzor na početak sledećeg reda


Ако занемарите мало чудан начин исписа, програм је крајње једноставан.
Узимамо све бројеве од 1 до 5, множимо сваки са сваким и приказујемо то
на екрану. Оно што је необично код исписа је што смо ставили да се испис
завршава „табом“, а не новим редом. То нам омогућава да испишемо пет
резултата у једном реду. Ред завршавамо тек када унутрашња петља стигне
до краја. Контролни знак за таб је „\\t“, а за нови ред „\\n“.

Условно гранање
---------------

Да би програм могао да одлучи који део кôда треба да изврши, потребно је
да провери испуњеност траженог критеријума, односно да евалуира
(вреднује) одговарајући логички исказ. У зависности од тога да ли је
услов испуњен или не, програм ће извршавати различите делове кôда. У
Пајтону се најчешће користи ``if ... then ... else`` конструкција. Прво
проверавамо да ли је испуњен услов наведен иза ``if``, ако јесте, онда
програм извршава оно што иде после ``then``, а ако није испуњен, извршава
оно што следи после ``else``. Погледајте пример.

.. activecode:: uslovno
    :nocodelens:

    a=int(input())       # traži unos sa tastature i prevaraga u integer
    if a%2==0:           # ako je ostatak pri deljenju sa 2 jednak nuli
        print('паран')   # štampaj da je broj paran
    else:                # ako nije
        print('непаран') # štampaj da je neparan
 
У овом примеру прво тражимо да неко помоћу тастатуре укуца број, онда
тај унос претворимо у интиџер и придружимо га променљивој ``a``. У
следећој линији проверавамо да ли је тај број дељив са 2, односно да ли
је остатак при дељењу са 2 једнак нули. Потом иде оно што треба извршити
ако је услов испуњен, тј. да програм испише да је унети број паран. У
противном исписује да је непаран.

.. suggestionnote:: 

    Обратите пажњу на синтаксу. У Пајтону се инструкција ``then`` уопште не
    користи. Уместо тога користи се двотачка и увучени блокови
    инструкција. Видите како се после реда који се завршава са двотачком
    појављује увучени део кôда. Први блок инструкција (који може да има
    произвољно много линија кôда) извршава се ако је услов испуњен, а други
    блок (после ``else:``) ако услов није испуњен.

Уколико гранање на две могућности није довољно, можемо да уведемо и нове
блокове помоћу ``elif`` инструкције. Нема ограничења колико ових услова
може да буде. Када први услов није испуњен, онда можемо да испитамо да
ли је неки други услов испуњен помоћу ``elif``. Погледајте пример.

.. activecode:: elif
    :nocodelens:

    a=5
    b=6
    if a==b:                           # ako su a i b jednaki
        print("a и b су једнаки.")     # ako su a i b jednaki
    elif a<b:                          # ako je a manje od b
        print("a је мање од b.")       # napiši da je a manje od b
    else:                              # u protivnom
        print("a је веће од b.")       # napiši da je a veće od b

Други начин да проверимо више услова је да у *if-then-else* блоковима
уведемо нове услове и ново гранање. Ако то радите, обратите пажњу да ти
нови блокови морају да буду још више увучени. Уколико је у случају првих то било по четири размака, онда ови угњеждени морају да буду увучени по осам. Едитор у коме радите
обично води рачуна о увлачењу блокова, али није лоше да проверите да ли
је све увучено како треба. За разлику од неких других програмских
језика, Пајтон неће да ради и пријављује грешку ако блокови нису
правилно увучени. Ево опције примера како смо претходни пример могли да урадимо
са угњежденим условима.

.. activecode:: viseuslova
    :nocodelens:

    a=6
    b=6
    if a<b:
        print("a је мање од b.")
    else:
        if a==b:
            print("a и b су једнаки.")
        else:
            print("a је веће од b.")

Гранање због грешке
~~~~~~~~~~~~~~~~~~~

Постоји могућност да направимо гранање које би нас штитило од ненамерне
грешке у извршавању програма. У идеалном случају, то нам није потребно,
али пракса говори да се грешке дешавају и да програми због тога престају
да раде. Ако можемо да претпоставимо каква је могућа грешка, онда можемо
да је контролишемо. Примера ради, пробајте да унесете децимални број у
горе приказани програм који исписује да ли је број паран или непаран.
Шта се дешава? Програм приказује информацију о “ValueError” грешци и
престаје да ради. Било би добро када бисмо могли реагујемо на грешку
тако што се онда изврши део програма предвиђен за такве
случајеве.

.. infonote:: 

    Инструкције ``try`` и ``except`` омогућавају да се програм регуларно
    заврши и онда када дође до грешке. Програм покушава да уради оно што је
    у блоку ``try``. Уколико дође до грешке, онда извршава оно у блоку
    ``except``.
    
Демонстрираћемо како *try-except* ради на примеру који смо
већ помињали.

.. activecode:: try
    :nocodelens:

    a=input()                          # unesi podatak sa tastature
    try:                               # proba
        a=int(a)                       # ako je a celobrojna vrednost u decimalnom obliku, promeni mu tip u integer
        if a%2==0:                     # i onda proveri da li je broj paran ili neparan
            print('паран')
        else:
            print('непаран')
    except:                                     # ako promena tipa u integer nije uspela
        print('Унели сте број који није цео.')  # onda samo ispiši poruku


Гранање *try-except* има сложенију структуру него што је приказано у
примеру. Два додатна блока ``else`` и ``finally`` дају додатне
могућности за управљање грешкама, али их овде нећемо објашњавати. Ако
вас интересује, пронађите упутство и прочитајте сами како раде.

Функције
--------

Пајтон има неке уграђене функције као што су ``sum()`` или ``min()``,
али за конкретну намену сами можемо да напишемо нову функцију. Функције
се једноставно дефинишу: у првој линији пишемо
``def <име функције>(<име променљиве у коју се смешта аргумент>):``,
онда следи блок инструкција којима обрађујемо и рачунамо нешто са
улазном променљивом, и на крају, у последњој линији, пишемо
``return <име излазне променљиве>``. Свака функција може да има више
улазних променљивих, као што може да врати и више излазних.

Први пример функције који ћемо овде приказати је рачунање производа свих
вредности у листи. Оваква функција не постоји у стандардној Пајтоновој
библиотеци. Зато је добро да знамо да је напишемо.

.. activecode:: funct1
    :nocodelens:
    
    def proizvod(L):     # argument, odnosno lista koju prosleđujemo funkciji biće smeštena u promenljivu
        p=1              # početna vrednost proizvoda je 1
        for x in L:      # za svaku vrednost iz liste
            p=p*x        # proizvod množimo tom vrednošću
        return p         # funkcija vraća proizvod svih vrednosti u listi

    proizvod([1,2,3,4,5])



.. questionnote:: 

    Задатак: Можете ли, по угледу на претходни пример, сами да напишете функцију ``zbir()`` која би сабрала све елементе листе?

    
.. activecode:: лифт_апсолутна_вредност_input
   :nocodelens:
   :runortest: test1, test2, test3
		
   # -*- acsection: general-init -*-
   # -*- acsection: main -*-
   def zbir(L):
      # dopuni ovu fuknciju
   # Провера
   test1 = zbir([1, 2, 3, 4, 5])
   test2 = zbir([100, 200, 500])
   test3 = zbir([-1, 0, 0, 4, 5]) 
   # -*- acsection: after-main -*-
   print(test1, test2, test3)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           L = [1, 2, 3, 4, 5]; rez1 = sum(L)
           L = [100, 200, 500]; rez2 = sum(L)
           L = [-1, 0, 0, 4, 5]; rez3 = sum(L)
           run_test = acMainSection(test1=test1,test2=test2,test3=test3)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде %s" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде %s" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде %s" % rez3)
   myTests().main() 

.. questionnote:: 
    
    Како бисте написали функцију чији је улаз листа, а излаз најмања
    вредност из те листе? Та функција треба да пронађе најмању вредност у
    листи и да је врати. Оваква функција већ постоји у Пајтону и зове се
    ``min()``, али ћемо искористи прилику да напишемо своју верзију. 

Име ове нове функције ће бити ``minimum()``. Ево једне могућности како то може
да се напише.

.. activecode:: minimum
    :nocodelens:

    def minimum(L): 
        m=L[0]            # za početak, najmanje vrednost će biti ona prva u listi
        for x in L[1:]:   # iteracije kreću od druge vrednosti u listi i idu do kraja
            if x<m:       # ako je tekuća vrednost iteratora x manja од m, tj. one koja je do sad bila najmanja
                m=x       # onda neka novi minimum bude
        return m          # na kraju funkcija vraća vrednost
    lista=[11,22,33,14,25,36,17,28,39,10,21,32]
    print(minimum(lista))

Библиотеке
----------

Пајтон без додатних библиотека има само основне типове података,
структуре и функције. У тој стандардној библиотеци нема структура у
којима бисмо чували табеле, нема функција које би цртале графиконе или
чак рачунале једноставне математичке функције. За све то је потребно да
учитамо библиотеке, модуле из библиотека или њихове појединачне
функције. Срећом, Пајтон има огроман број врло квалитетних библиотека до
којих се лако долази.

Библиотеке се састоје из модула који у себи садрже разне типове
података, објекте, функције и методе за те објекте итд. Стандардна
библиотека има неколико модула које не учитава аутоматски. То значи да
су модули инсталирани, али да треба да их учитамо. Међу њима су модули
који су нам често потребни као што су ``math`` (математичке функције),
``random`` (генерисање случајних бројева) или ``statistics``
(статистичке функције).

Када учитамо целу библиотеку или модул помоћу инструкције ``import``,
можемо да користимо све њене функције и објекте, само морамо да наведемо
одакле су преузети. На пример, када учитамо библиотеку ``math``, добићемо
и функције и константе које уз њу иду. Кад их позивамо, прво куцамо име
библиотеке са тачком на крају, тј. ``math.`` па онда име функције или
константе. Ево примера где програм прво исписује вредност константе
:math:`\pi`, а затим и косинус од тог броја:

.. activecode:: ipython3
    :nocodelens:

    import math
    print(math.pi)
    print(math.cos(math.pi))

Има библиотека које имају непрактично дуга имена па би било тешко стално
укуцавати њихова имена кад хоћемо да позивамо њихове функције. У тим
случајевима већ при учитавању библиотеке кажемо Пајтону да ћемо је
убудуће позивати по „надимку“, тј. скраћеној верзији имена коју можемо
сами да смислимо. У следећој ћелији је пример како учитавамо библиотеку
``matploylib.pyplot`` одређујући да ћемо је убудуће звати само ``plt``.

.. code:: ipython3

    import matplotlib.pyplot as plt
    plt.plot([4,2,3,4,3])




.. parsed-literal::

    [<matplotlib.lines.Line2D at 0x26d58a0b160>]




.. image:: ../../_images/output_104_1.png


Ако нас интересује само једна функција из библиотеке, можемо њу посебно
да учитамо помоћу линије
``from <назив библиотеке> import <назив функције>``. Тада при употреби
не морамо да наводимо из које је библиотеке. На пример, ако из целог
модула ``statistics`` хоћемо само функцију ``mean()`` која рачуна средњу
вредност низа, то можемо да урадимо на следећи начин:

.. code:: ipython3

    from statistics import mean
    mean([3,4,4,6])




.. parsed-literal::

    4.25

.. infonote:: 

    Многе важне екстерне библиотеке су већ инсталиране у Џупитер окружењу.
    Оне које се најчешће користе су ``pandas``, за рад са табелама и
    фајловима, ``matplotlib.pyplot``, за цртање графикона, и ``numpy``, за рад
    са вишедимензионалним подацима. Уколико тражене библиотеке нема у
    окружењу, потребно је да је инсталирате. У већини случајева нема потребе
    да библиотеку тражите на интернету и да је преузимате. Довољно је да
    укуцате ``pip install <назив библиотеке>`` и Пајтон ће библиотеку сам
    пронаћи, преузети и инсталирати.
