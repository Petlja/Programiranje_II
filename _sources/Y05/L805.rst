Сортирање
=================

У овој лекцији се бавимо сортирањем низова.

1. Прво показујемо како се низови сортирају позивом уграђене функције.
2. Потом имплементирамо алгоритам за сортирање бирањем најмањег елемента (*selection sort*).
3. На крају показујемо бабл-сорт (*bubble sort*).


Сортирање низова позивом уграђене функције
-----------------------------------------------

Сортирати низ значи испремештати његове елементе тако да буду поређани по величини, од мањих ка већим или обрнуто. На пример:

.. math::

   [3, 1, 2, 5, 0, -1, 4] \to [-1, 0, 1, 2, 3, 4, 5]

Уграђена функција ``sort`` сортира низ и позива се овако:

.. activecode:: primer5-1

   L = [3, 1, 2, 5, 0, -1, 4]
   L.sort()
   print(L)

Видимо да су елементи поређани од мањих ка већим вредностима.
Ако желимо да поређамо елементе низа ``L`` од већих ка мањим вредностима, то можемо да урадимо овако:

.. activecode:: primer5-2

   L = [3, 1, 2, 5, 0, -1, 4]
   L.sort(reverse=True)
   print(L)

Опција ``reverse=True`` каже функцији ``sort`` да желимо да сортирамо елементе низа у "обрнутом" поретку:
од већих ка мањим вредностима.

Дакле, лако је сортирати низова бројева. И низове стрингова је лако сортирати.
Нека нам је дат списак имена ученика једног разреда. Он се такође може сортирати позивом уграђене функције ``sort``:

.. activecode:: primer5-3

   razred = [
       "Nenadović, Nenad",
       "Petrović, Petar",
       "Milanović, Milan",
       "Anić, Ana",
       "Vuković, Vuk",
       "Sarić, Sara"
   ]
   razred.sort()
   print(razred)

Пошто су имена у примеру написана латиницом низ ће бити сортиран абецедно. Ако су имена написана ћирилицом
низ ће бити сортиран азбучно, како показује следећи пример:

.. activecode:: primer5-4

   razred = [
      "Ненадовић, Ненад",
      "Петровић, Петар",
      "Милановић, Милан",
      "Анић, Ана",
      "Вуковић, Вук",
      "Сарић, Сара"
   ]
   razred.sort()
   print(razred)


Пример.
''''''''

Написати програм који од корисника учитава природан број :math:`n` који представља број запослених у
некој компанији, и природан број :math:`k`, потом учитава :math:`n` реалних бројева који представљају
зараде запослених и штампа :math:`k` највећих зарада у компанији.

*Решење.*
Потребно је зараде сортирати од већих ка мањим вредностима и онда исписати првих :math:`k` елемената
тако сортираног низа.

.. activecode:: primer5-444
   :includesrc: _src/P05/K_najvecih.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај програм ``K_najvecih.py`` и изврши га.

Пример.
''''''''

Написати програм који од корисника учитава *паран* природан број :math:`n`, потом
:math:`n` различитих реалних бројева и онда одређује и штампа реалан број :math:`m`
такав да је тачно половина од учитаних бројева мања од :math:`m`, а друга половина
већа од :math:`m`. Зна се да је :math:`n` паран број и то не треба проверавати.
Такође се зна да ће сви учитани реални бројеви бити различити и то не треба проверавати.

На пример, за :math:`n = 10` и бројеве

    1.5  3.7  2.25  9.81  3.1415  -0.26  2.9  8.11  10.12  -5.41

једна могућност за :math:`m` је :math:`m = 3.02075` зато што је тачно пет од десет наведених бројева
мање од 3.02, док су осталих пет бројева већи.

*Решење.*

Идеја решења се састоји у томе да се учитани низ сортира, па да се нађе број који је између два
"средња броја". На пример, за бројеве

    1.5  3.7  2.25  9.81  3.1415  -0.26  2.9  8.11  10.12  -5.41

након сортирања добијамо

    -5.41   -0.26  1.5  2.25  2.9  3.1415  3.7  8.11  9.81  10.12

Два броја "на средини" сортираног низа су 2.9 и 3.1415, па за број :math:`m` можемо узети њихову
аритметичку средину:

.. math::

   \frac{2.9 + 3.1415}{2} = 3.02075

.. activecode:: primer5-445
   :includesrc: _src/P05/Broj_na_sredini.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај програм ``Broj_na_sredini.py`` и изврши га.


Како раде алгоритми за сортирање
------------------------------------------------------------

Погледајмо следећи пример у коме нам је за групу ученика дато неколико података о њима (име, пол, старост, маса и висина):

.. code-block:: python

   razred = [["Ana",     "ž", 13, 46, 160],
             ["Bojan",   "m", 14, 52, 165],
             ["Vlada",   "m", 13, 47, 157],
             ["Gordana", "ž", 15, 54, 165],
             ["Dejan",   "m", 15, 56, 163],
             ["Đorđe",   "m", 13, 45, 159],
             ["Elena",   "ž", 14, 49, 161],
             ["Žaklina", "ž", 15, 52, 164],
             ["Zoran",   "m", 15, 57, 167],
             ["Ivana",   "ž", 13, 45, 158],
             ["Jasna",   "ž", 14, 51, 162]]

Овај низ података можемо сортирати по разним критеријумима: по имену, или по старости, или по висини, или по маси.
Постоји начин да се уграђеној функцији ``sort`` зада критеријум за сортирање, али је он веома апстрактан и оставићемо
га за неки каснији сусрет са програмирањем. Ми ћемо овај проблем решити тако што ћемо написати
*наш алгоритам за сортирање* којим ћемо моћи да соритрамо произвољне податке по критеријуму који нам у том тренутку одговара.

У наставку показујемо како раде два стандардна алгоритма за сортирање:

- Сортирање бирањем најмањег елемента (*selection sort*), и
- Бабл-сорт алгоритам (*bubble sort*)

Сортирање бирањем најмањег елемента (*selection sort*)
------------------------------------------------------------

Сортирање бирањем најмањег елемента (од енглеског *selection sort*) је један од стандардних алгоритама за сортирање.
Основна идеја овог алгоритма је веома једноставна:

1. Нађемо најмањи елемент у низу и ставимо га на прво место, а елемент који се затекао на првом месту преместимо негде да нам не смета, рецимо на место на коме је стајао најмањи елемент (и које је сада слободно).
2. Потом нађемо најмањи елемент *у остатку низа* (дакле у низу кога чине елементи од другог до последњег) и њега ставимо на друго место; елемент који се затекао на другом месту ставимо негде да нам не смета, рецимо на место елемента кога смо преместили на друго место.
3. Потом нађемо најмањи елемент *у остатку низа* (дакле у низу кога чине елементи од трећег до последњег) и њега ставимо на треће место; ...

и тако до краја низа. На пример пођимо од низа:

.. code-block:: text

    3, 1, 2, 5, 0, -1, 4

Најмањи елемент у том низу је -1 и ми ћемо га практично заменити са првим елементом:

.. code-block:: text

    -1; 1, 2, 5, 0, 3, 4

За потребе овог примера иза елемента -1 смо ставили ознаку ``;`` како бисмо означили да је тај део низа сортиран и
да га не треба даље разматрати. Најмањи број *у остатку низа* (дакле, иза знака `;`) је 0, па ћемо тај елемент заменити
са другим елементом низа:

.. code-block:: text

    -1, 0; 2, 5, 1, 3, 4

Тако смо сортирани део низа продужили за једно место. Најмањи број *у остатку низа* (дакле, иза знака ``;``)
сада је 1, па ћемо га заменити са трећим елементом низа:

.. code-block:: text

    -1, 0, 1; 5, 2, 3, 4

Најмањи број *у остатку низа* (дакле, иза знака ``;``) је 2, и њега ћемо заменити са четвртим елементом низа:

.. code-block:: text

    -1, 0, 1, 2; 5, 3, 4

Најмањи број *у остатку низа* је 3, и њега ћемо заменити са петим елементом низа:

.. code-block:: text

    -1, 0, 1, 2, 3; 5, 4

Коначно, најмањи број *у остатку низа* је 4, и њега ћемо заменити са шестим елементом низа:

.. code-block:: text

    -1, 0, 1, 2, 3, 4; 5

Алгоритам се завршава када у несортираном делу низа остане само један елемент, јер је он сигурно најмањи *у несортираном
делу низа*, и нема потребе да га замењујемо са њим самим.

Ево Пајтон функције која тачно тако сортира низ:

.. code-block:: python

   def selection_sort(L):
       n = len(L)
       if n <= 1: return
       for i in range (n-1):
           m = i
           for j in range(i+1,n):
               if L[j] < L[m]: m = j
           L[i], L[m] = L[m], L[i]

Неколико коментара:

1. за празне низове и низове дужине 1 не треба ништа радити (нпр. низ [3] је већ сортиран);
2. у спољашњем ``for`` циклусу индекс ``i`` иде до претпоследњег места зато што ће постављањем праве вредности на претпоследње
   местo уједно и на последње место бити постављена одговарајућа вредност, како смо видели у претходном примеру;
3. променљива ``m`` садржи индекс најмањег елемента *у остатку* низа; зато унутрашњи ``for`` циклус креће од ``i+1``;
4. наредба ``a, b = b, a`` размењује вредност променљивих ``a`` и ``b``; зато наредба ``L[i], L[m] = L[m], L[i]``
   размењује вредност првог елемента несортираног дела низа (што је ``L[i]``) са најмањим елементом у несортираном делу низа
   (што је ``L[m]``).

Пример.
''''''''''''''''''''''''

Написати програм који од корисника учитава природан број :math:`n` који представља број запослених у
некој компанији, потом учитава :math:`n` реалних бројева који представљају
зараде запослених и штампа те зараде по величини, од највеће до најмање.

.. activecode:: primer5-446
   :includesrc: _src/P05/Od_najvece_do_najmanje.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај програм ``Od_najvece_do_najmanje.py`` и изврши га.


Пример.
''''''''''''''''''''''''

Решићемо поново следећи задатак.
Написати програм који од корисника учитава природан број :math:`n` који представља број запослених у
некој компанији, и природан број :math:`k`, потом учитава :math:`n` реалних бројева који представљају
зараде запослених и штампа :math:`k` највећих зарада у компанији.

*Решење.*
Потребно је зараде сортирати од већих ка мањим вредностима и онда исписати првих :math:`k` елемената
тако сортираног низа. Зато што се у задатку од нас тражи да испишемо само првих
:math:`k` највећих зарада у компанији применићемо наш алгоритам за сортирање док не
Овај пут ћемо применити наш алгоритам

.. activecode:: primer5-447
   :includesrc: _src/P05/Samo_K_najvecih.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај програм ``Samo_K_najvecih.py`` и изврши га.


Пример.
''''''''

У следећем низу је за групу ученика дато неколико података о њима (име, пол, старост, маса и висина):

.. code-block:: python

   razred = [["Ana",     "ž", 13, 46, 160],
             ["Bojan",   "m", 14, 52, 165],
             ["Vlada",   "m", 13, 47, 157],
             ["Gordana", "ž", 15, 54, 165],
             ["Dejan",   "m", 15, 56, 163],
             ["Đorđe",   "m", 13, 45, 159],
             ["Elena",   "ž", 14, 49, 161],
             ["Žaklina", "ž", 15, 52, 164],
             ["Zoran",   "m", 15, 57, 167],
             ["Ivana",   "ž", 13, 45, 158],
             ["Jasna",   "ž", 14, 51, 162]]

Написати Пајтон функцију ``selection_sort_by(k, L)`` која овако структуиране податке у низу ``L`` сортира по садржају
колоне ``k``. На пример, ``selection_sort_by(0, razred)`` ће сортирати низ ``razred`` по колони 0, дакле, по имену.

.. activecode:: primer5-10
   :includesrc: _src/P05/SelSort_po_kriterijumu.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај програм ``SelSort_po_kriterijumu.py`` и изврши га.


Бабл-сорт алгоритам (*bubble sort*)
---------------------------------------

Бабл-сорт (од енглеског *bubble sort* што би могло да се преведе као "мехуричасти сорт") је један од стандардних алгоритама
за сортирање низова. Он није најбржи, али је погодан када низ који соритрамо није превише "чупав". Тада ради брже од сортирања
бирањем најмањег елемента.

Идеја бабл-сорт алгоритма је такође једноставна:

1. Упоредимо први и други елемент низа, па ако је први већи од другог заменимо им места.
2. Онда упоредимо други и трећи елемент низа, па ако је други већи од трећег замени им места.
3. Онда упоредимо трећи и четврти елемент низа, и тако до краја низа.
4. Ако смо у овом пролазу кроз низ направили бар јену замену, кренемо из почетка.
5. Када прођемо кроз низ и не направимо ниједну замену, низ је сортиран (јер је први елемент мањи од другог, други мањи од трећег, итд).

На пример пођимо од низа:

.. code-block:: text

    3, 1, 2, 5, 0, -1, 4
    #--#

Крећемо први пролаз кроз низ. Пошто је први елемент већи од другог, заменимо им места.

.. code-block:: text

    1, 3, 2, 5, 0, -1, 4
       #--#

Сада поредимо други и трећи елемент низа. Пошто је други већи од трећег, заменимо им места.

.. code-block:: text

    1, 2, 3, 5, 0, -1, 4
          #--#

Трећи елемент није већи од четвртог, па овде не треба мењати места елементима низа.

.. code-block:: text

    1, 2, 3, 5, 0, -1, 4
             #--#

Како је 5 веће од 0, заменимо места елементима.

.. code-block:: text

    1, 2, 3, 0, 5, -1, 4
                #---#

Поново заменимо места.

.. code-block:: text

    1, 2, 3, 0, -1, 5, 4
                    #--#

И још једном.

.. code-block:: text

    1, 2, 3, 0, -1, 4, 5

Овим је окончан први пролаз кроз низ. Приметимо да је у првом пролази највећи елемент низа стигао на крај,
као мехурић који се пење у чаши (по овој аналогији је бабл-сорт и добио име: енгл. *bubble* = мехур).
Зато у наредном пролазу нема потребе ићи до крја низа. Довољно је упоређивати елементе до претпоследњег елемента.
Други пролаз изгледа овако:

.. code-block:: text

    1, 2, 3, 0, -1, 4, 5
    #--#

    1, 2, 3, 0, -1, 4, 5
       #--#

    1, 2, 3, 0, -1, 4, 5
          #--#

    1, 2, 0, 3, -1, 4, 5
             #---#

    1, 2, 0, -1, 3, 4, 5
                 #--#

Видимо да је на крају другог пролаза други највећи елемент "испливао на површину". Овим је окончан други пролаз.
Након трећег пролаза низ постаје:

.. code-block:: text

    1, 0, -1, 2, 3, 4, 5

а након четвртог:

.. code-block:: text

    0, -1, 1, 2, 3, 4, 5

У петом пролазу нећемо ниједном пару елемената заменити места, и процес се зауставља.

Ево Пајтон функције која тачно тако сортира низ:

.. code-block:: python

   def bubble_sort(L):
       n = len(L)
       if n <= 1: return
       zamena = True
       while zamena:
           zamena = False
           for i in range(n-1):
               if L[i] > L[i+1]:
                   zamena = True
                   L[i], L[i+1] = L[i+1], L[i]
           n -= 1

Неколико коментара:

1. за празне низове и низове дужине 1 не треба ништа радити (нпр. низ [3] је већ сортиран);
2. променљива ``zamena`` садржи информацију о томе да ли смо направили бар једну замену места суседних елемената;
   иницијално је постављамо на ``True`` како бисмо отпочели сортирање;
3. одмах након уласка у циклус је постављамо на ``False`` и тек ако се током проласка кроз низ направи бар једна замена
   њена вредност ће бити враћена на ``True``;
4. на крају тела циклуса смањујемо ``n`` за један зато што сваком пролазом кроз циклус још један "мехурић исплива на површину"
   и тај део низа нема потребе даље проверавати (крај низа је увек сортиран);
5. циклус ће се завршити када прођемо кроз низ и не направимо ниједну замену; то значи да ниједaн елемент није већи од свог
   десног суседа, односно, да је низ сортиран.

Пример.
''''''''

У следећем низу је за групу ученика дато неколико података о њима (име, пол, старост, маса и висина):

.. code-block:: python

   razred = [["Ana",     "ž", 13, 46, 160],
             ["Bojan",   "m", 14, 52, 165],
             ["Vlada",   "m", 13, 47, 157],
             ["Gordana", "ž", 15, 54, 165],
             ["Dejan",   "m", 15, 56, 163],
             ["Đorđe",   "m", 13, 45, 159],
             ["Elena",   "ž", 14, 49, 161],
             ["Žaklina", "ž", 15, 52, 164],
             ["Zoran",   "m", 15, 57, 167],
             ["Ivana",   "ž", 13, 45, 158],
             ["Jasna",   "ž", 14, 51, 162]]

Написати Пајтон функцију ``bubble_sort_by(k, L)`` која овако структуиране податке у низу ``L`` сортира по садржају
колоне ``k``. На пример, ``bubble_sort_by(0, razred)`` ће сортирати низ ``razred`` по колони 0, дакле, по имену.

.. activecode:: primer5-11
   :includesrc: _src/P05/BubSort_po_kriterijumu.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај програм ``BubSort_po_kriterijumu.py`` и изврши га.


Задаци.
---------

Задатак 1.
''''''''''''''''''''''

Написати Пајтон функцију ``kti_po_velicini(L, k)`` која враћа елемент низа ``L`` који је k-ти по величини
у том низу.

.. activecode:: primer5-Z1
   :runortest: test1, test2, test3
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-

   def kti_po_velicini(L, k):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = kti_po_velicini([3, 1, 2, 5, 4, 7, 1, 0], 1)
   test2 = kti_po_velicini([3, 1, 2, 5, 4, 7, 1, 0], 3)
   test3 = kti_po_velicini([3, 1, 2, 5, 4, 7, 1, 0], 8)
   # -*- acsection: after-main -*-
   
   print(test1, test2, test3)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           def __kpv(L, k):
              L.sort(reverse=True)
              return L[k-1]
           rez1 = __kpv([3, 1, 2, 5, 4, 7, 1, 0], 1)
           rez2 = __kpv([3, 1, 2, 5, 4, 7, 1, 0], 3)
           rez3 = __kpv([3, 1, 2, 5, 4, 7, 1, 0], 8)
           run_test = acMainSection(test1=test1,test2=test2,test3=test3)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде '%s'" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде '%s'" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде '%s'" % rez3)
   myTests().main()



Задатак 2.
''''''''''''''''''''''

*Медијана* низа је елемент низа који се налази тачно на средини низа по величини. Написати Пајтон функцију
``medijana(L)`` која одређује медијану низа ``L``. (Уколико низ има парно много елемената, вратити елемент који је најближи
средини низа када се његови елементи поређају по величини.)

.. activecode:: primer5-Z2
   :runortest: test1, test2, test3
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-

   def medijana(L):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = medijana([3, 1, 2])
   test2 = medijana([3, 1, 2, 5, 4, 7, 1])
   test3 = medijana([4, 1, 2, 5, 4, 7, 1, 9])
   # -*- acsection: after-main -*-
   
   print(test1, test2, test3)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           def __m(L):
              L.sort()
              n = len(L)
              return L[n//2]
           rez1 = __m([3, 1, 2])
           rez2 = __m([3, 1, 2, 5, 4, 7, 1])
           rez3 = __m([4, 1, 2, 5, 4, 7, 1, 9])
           run_test = acMainSection(test1=test1,test2=test2,test3=test3)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде '%s'" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде '%s'" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде '%s'" % rez3)
   myTests().main()



Задатак 3*.
''''''''''''''''''''''


За два низа бројева кажемо да је један *пермутација* оног другог ако се елементи првог низа
могу испремештати тако да се добије онај други низ. Написати Пајтон функцију ``permutacija_od(L, M)`` која проверава да ли
је низ ``M`` пермутација низа ``M``.

*Идеја решења.* Сортирај оба низа и провери да ли су добијени низови једнаки!

.. activecode:: primer5-Z5666
   :runortest: test1, test2, test3
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-

   def permutacija_od(L, M):
       # Овде напиши функцију
       return -1234 # поправи овај ред

   test1 = permutacija_od([2, 1, 4, 5, 3], [5, 4, 1, 3, 2]) # jeste
   test2 = permutacija_od([1, 2, 4, 3], [2, 4, 5, 1]) # nije
   test3 = permutacija_od([3, 1, 4, 2], [2, 3, 2, 4]) # nije
   # -*- acsection: after-main -*-

   print(test1, test2, test3)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           rez1 = True
           rez2 = False
           rez3 = False
           run_test = acMainSection(test1=test1,test2=test2,test3=test3)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде '%s'" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде '%s'" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде '%s'" % rez3)
   myTests().main()


Задатак 4.
''''''''''''''''''''''

Написати Пајтон функцију ``selection_sort_desc(L)`` која сортира низ стратегијом бирања највећег елемента
(*selection sort*), тако да елементи низа буду поређани од највећег до најмањег елемента.

.. activecode:: primer5-Z4

   def selection_sort_desc(L):
       # Овде напиши функцију

   # Провера
   test1 = [3, 1, 4, 2, 7]
   selection_sort_desc(test1)
   test2 = [1, 2, 3, 4]
   selection_sort_desc(test2)
   test3 = [4, 3, 2, 1]
   selection_sort_desc(test3)

   print(test1)
   print(test2)
   print(test3)


Задатак 5.
''''''''''''''''''''''

Написати Пајтон функцију ``bubble_sort_desc(L)`` која сортира низ бабл-сорт стратегијом,
али тако да елементи низа буду поређани од највећег до најмањег елемента.

.. activecode:: primer5-Z555

   def bubble_sort_desc(L):
       # Овде напиши функцију

   # Провера
   test1 = [3, 1, 4, 2, 7]
   bubble_sort_desc(test1)
   test2 = [1, 2, 3, 4]
   bubble_sort_desc(test2)
   test3 = [4, 3, 2, 1]
   bubble_sort_desc(test3)
   
   print(test1)
   print(test2)
   print(test3)




Задатак 6*.
''''''''''''''''''''''

*Хиршов h-индекс* је једна од мера научне компетенције истраживача. Хиршов h-индекс неког истраживача је :math:`n`
ако тај истраживач има барем :math:`n` научних радова од којих је сваки цитиран барем :math:`n` пута.

На пример,

.. code-block:: text

   Цитираност научних радова     Хиршов h-индекс     Образложење
   -------------------------     ---------------     --------------------------------------------------------
   [0, 0, 0]                     0                   ниједан рад није цитиран ниједном
   [1, 1, 1, 1, 1, 1]            1                   има један рад који је цитиран једном, а нема
                                                     два рада од којих је сваки цитиран бар два птуа
   [1, 2, 1, 1, 1, 1]            1                   (исто као горе)
   [1, 1, 10, 1, 5, 1]           2                   има два рада који су цитирани бар два пута, а нема
                                                     три рада са особином да је сваки цитиран бар три пута
                                                      
Написати Пајтон функцију ``h_indeks(citiranost)`` која за листу са бројевима цитата научних радова истраживача (као у примеру)
рачуна Хиршов h-индекс тог истраживача.

*Идеја решења.* Сортирати листу од већих ка мањим вредностима и онда проверити да ли је на првом месту тако сортиране листе број који
је већи или једнак са 1, да ли је на другом месту број који је већи или једнак са 2, да ли је на трећем месту број који је
већи или једнак са 3 итд. Водити рачуна о томе да индекси низова у Пајтону почињу од 0.

.. activecode:: primer5-Z-хирш
   :runortest: test1, test2, test3, test4
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-

   def h_indeks(citiranost):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = h_indeks([0, 0, 0])
   test2 = h_indeks([1, 1, 1, 1, 1, 1])
   test3 = h_indeks([1, 2, 1, 1, 1, 1])
   test4 = h_indeks([1, 1, 10, 1, 5, 1])
   # -*- acsection: after-main -*-
   
   print(test1, test2, test3, test4)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           rez1 = 0
           rez2 = 1
           rez3 = 1
           rez4 = 2
           run_test = acMainSection(test1=test1,test2=test2,test3=test3,test4=test4)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде '%s'" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде '%s'" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде '%s'" % rez3)
           self.assertEqual(run_test["test4"], rez4, "Вредност променљиве 'test4' треба да буде '%s'" % rez4)
   myTests().main()



Задатак 7.
''''''''''''''''''''''

Написати Пајтон функцију ``po_prezimenu(L)`` која податке о ученицима једног разреда сортира по презимену.
Подаци о ученицима су дати низом у коме сваки ред садржи име, презиме и оцене ученика, на пример овако:

.. code-block:: python

   razred = [
       ["Dejan", "Dejanović", 3, 4, 5, 4, 5],
       ["Mara", "Marić", 4, 5, 5, 4, 2],
       ["Miloš", "Milošević", 2, 5, 4, 3, 3],
       ["Petar", "Marković", 5, 4, 5, 5, 5]
   ]

.. activecode:: primer5-Z3
   :includesrc: _src/P05/Po_prezimenu.py

.. infonote::

   Реши задатак и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај датотеку ``Po_prezimenu.py`` и ту реши задатак.

Задатак 8.
''''''''''''''''''''''

На такмичењу из информатике такмичари су радили по 4 задатка. Подаци о именима такмичара и о томе колико су
поена за који задатак освојили дати су низом као у следећем примеру:

.. code-block:: python

   takmicenje = [
       ["Dejan", 25, 25, 0, 25],
       ["Mira", 25, 0, 20, 25],
       ["Milan", 0, 0, 10, 0],
       ["Milica", 25, 25, 25, 25],
       ["Nenad", 10, 0, 25, 5]
   ]
   
Написати Пајтон функцију ``rang_lista(T)`` која за овако представљене исписује ранг-листу. На пример,

.. code-block:: python

    rang_lista(takmicenje)

треба да испише:

.. code-block:: text

    Milica 100
    Dejan 75
    Mira 70
    Nenad 40

.. activecode:: primer5-Z7
   :includesrc: _src/P05/Rang_lista.py

.. infonote::

   Реши задатак и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај датотеку ``Rang_lista.py`` и ту реши задатак.


Задатак 9.
''''''''''''''''''''''

У једном одељењу има :math:`n` ученика које треба поделити у две групе (јачу и слабију)
по успеху. Написати Пајтон програм који од корисника учитава природан број :math:`n`, потом за сваког ученика
учитава његово име и просечну оцену, и онда штампа извештај о томе како поделити разред у две групе тако да не
постоји ученик у првој групи који има слабији успех од неког ученика у другој групи. Групе треба да имају исти број
ученика, а ако то није могуће онда једна група може да има тачно једног ученика више од друге.

Решење смо започели за тебе:

.. activecode:: primer5-Z100
   :includesrc: _src/P05/Jaca_i_slabija_grupa.py

.. infonote::

   Реши задатак и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај датотеку ``Jaca_i_slabija_grupa.py`` и ту реши задатак.

Задатак 10.
''''''''''''''''''''''

У једном одељењу има :math:`n` ученика које треба поделити у две групе које су у једначене по успеху.
Написати Пајтон програм који од корисника учитава природан број :math:`n`, потом за сваког ученика
учитава његово име и просечну оцену, и онда штампа извештај о томе како поделити разред у две групе.
Поделу у групе реализовати овако. Прво треба поређати ученике по успеху, од најбољег ка најлошијем, па
онда првог, трећег, петог, седмог, ... ученика са тог списка ставити у прву групу, а другог, четвртог, шестог, осмог, ...
у другу.

Решење смо започели за тебе:

.. activecode:: primer5-Z101
   :includesrc: _src/P05/Dve_grupe.py

.. infonote::

   Реши задатак и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај датотеку ``Dve_grupe.py`` и ту реши задатак.




Задатак 11.
''''''''''''''''''''''

Написати Пајтон функцију ``svi_razliciti(L)`` која проверава да ли су сви елементи низа ``L`` различити.

.. activecode:: primer5-Z6
   :includesrc: _src/P05/Svi_razliciti.py

.. infonote::

   Реши задатак и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај датотеку ``Svi_razliciti.py`` и ту реши задатак.

  
Задатак 12*.
''''''''''''''''''''''

Написати Пајтон функцију која за два стринга утврђује да ли је први анаграм оног другог.
На пример, стринг "I am Lord Voldemort" је анаграм стринга "Tom Marvolo Riddle". Обратити пажњу на то да приликом
провере да ли је један стринг анаграм оног другог празнине и величина слова не играју никакву улогу!

.. activecode:: primer5-Z8
   :includesrc: _src/P05/Anagram.py

.. infonote::

   Реши задатак и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P05`` учитај датотеку ``Anagram.py`` и ту реши задатак.


Задаци из Алгоритамске збирке задатака
----------------------------------------------

Решавањем следећих задатака можете да увежбате додатне вештине у вези са сортирањем низова. 

https://petlja.org/biblioteka/r/problemi/Zbirka/sortiranje_brojeva

https://petlja.org/biblioteka/r/problemi/Zbirka/najvredniji_predmeti

https://petlja.org/biblioteka/r/problemi/Zbirka/objedinjavanje

https://petlja.org/biblioteka/r/problemi/Zbirka/presek_tri_sortirana_niza
