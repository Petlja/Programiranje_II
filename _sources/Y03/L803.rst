Низови симбола (*стрингови* или *ниске*)
===========================================

У овој лекцији ћемо:

1. упознати стрингове као низове карактера
2. видети како се приступа елементима стринга и како се издвајају делови стринга, и
3. упознати основне операције са стринговима.

Стрингови (ниске)
-----------------

Иако су настали као машине за обраду нумеричких података рачунари су доживели врхунас свог успеха
када се схватило да они могу да обрађују и *симболичке* податке. Обрада симболичких података данас
представља доминантан начин употребе рачунара.

*Стринг* је реч књижевног енглеског језика (енгл. *string*) чије основно значење је
"објекти исте врсте нанизани на нит". Зато се стрингови често на српском зову и *ниске*.
У Пајтону стринг је низ симбола. На пример, ово су стрингови:

.. code-block:: python

   "Zdravo! Kako si?"
   'Основна школа "Јован Јовановић-Змај"'
   ":-)"
   ''
   ""

Видимо да се стрингови пишу тако што се између апострофа или наводника (свеједно је) наведе произвољан низ симбола.
Последња два примера нам показују како изгледа *празан стринг*, односно, стринг који нема ниједно слово.
Други пример нам показује како да се снађемо ако стринг треба да садржи наводнике: просто га оградимо апострофима.

Број симбола у стрингу се зове *дужина стринга*. Дужине стрингова из претходног примера су, редом, 16, 36, 3, 0 и 0.

Стрингове додељујемо променљивим као што смо и навикли, исписујемо их командом `print`, а учитавамо командом `input`.
Команда `input` сачека да корисник унесе низ симбола и да на крају притисне [ENTER]. Она потом врати све симболе
које је корисник унео као један низ симбола (такорећи *стринг*). На пример:

.. activecode:: primer3-1
   :includesrc: _src/P03/Vokativ.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Vokativ.py`` и изврши га.

   Ево и кратке видео демонстрације:
   
   .. ytpopup:: EhYScc6wZOo
      :width: 735
      :height: 415
      :align: center


Уграђена функција ``len`` враћа дужину стринга и користи се овако:

.. activecode:: primer3-2

   ime = input("Unesi ime:")
   print("Ti se zoveš", ime, "i tvoje ime ima", len(ime), "slova")

Пример.
'''''''

Написати Пајтон програм који утврђује колико пута се неки симбол јавља у унетом стрингу.

.. activecode:: primer3-3
   :includesrc: _src/P03/Broj_simbola.py

Конструкција ``for x in s`` прође кроз цео стринг ``s`` слово по слово, па за свако појављивање симбола ``c`` увећамо бројач за 1.

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Broj_simbola.py`` и изврши га.


Пример.
'''''''

Написати Пајтон програм који утврђује да ли је у датом стрингу број отворених заграда ``(`` једнак броју затворених заграда ``)``.

.. activecode:: primer3-4
   :includesrc: _src/P03/Zagrade.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Zagrade.py`` и изврши га.

   
Приступање елементима стринга и деловима стринга
------------------------------------------------

Пошто је стринг низ симбола могуће је приступити појединачним симболима у стрингу, али и деловима стринга.

.. image:: ../../_images/Y103.jpg
   :width: 800

Стринг је, дакле, низ кућица. У сваку кућицу је уписан тачно један симбол и свака кућица има кућни број.
Као и раније, кућни бројеви крећу од нуле. На пример, ако ставимо

.. code-block:: python

   s = "Popokatepetl"

онда имамо:

.. activecode:: primer3-5

   s = "Popokatepetl"
   print(s[4])
   print(s[0])

Инересантно је (а касније ћемо видети да је и корисно!) то што низови у Пајтону имају и негативне индексе.
Последња кућица у низу има индекс -1 ("први од краја"), претпоследња -2 ("други од краја") и тако даље. Зато је:

.. activecode:: primer3-6

   s = "Popokatepetl"
   print(s[-1])
   print(s[-5])

Из стринга можемо лако да издвојимо његове делове употребом конструкције ``s[m:n]``
која издваја део стринга који почиње од кућице са редним бројем *m* и завршава се са кућицом чији редни број је *n - 1*
(обрати пажњу: кренемо од *m*, али **не идемо** до *n* већ до кућице пре). На ово ћемо морати мало да се привикнемо. На пример,

.. activecode:: primer3-7

   s = "Popokatepetl"
   print(s[2:5])

Дакле, из стринга *s* смо издвојили симболе *s[2]*, *s[3]* и *s[4]*, односно, кренули смо од кућице број 2 и завршили
*непосредно пре* кућице број 5.

Ако желимо да издвојимо део стринга који креће од 6. кућице и иде до краја стринга, написаћемо *s[6:]*

.. activecode:: primer3-8

   s = "Popokatepetl"
   print(s[6:])

С друге стране, ако желимо да издвојимо део стринга који креће од почетка стринга и иде до 6. кућице (укљућујући и њу) написаћемо
*s[:7]*

.. activecode:: primer3-9

   s = "Popokatepetl"
   print(s[:7])

*Не смемо заборавити да се кућица чији кућни број је наведен иза двотачке не укључује у сегмент!*

Издвајање делова стринга у комбинацији са негативним индексима нам омогућује да концизно запишемо веома корисне конструкције.
Рецимо, последња четири елемента стринга добијамо овако:

.. activecode:: primer3-10

   s = "Popokatepetl"
   print(s[-4:])

што је концизан запис за део стринга "од -4. кућице па до краја". С друге стране, "све осим последња два" можемо да запишемо овако:

.. activecode:: primer3-11

   s = "Popokatepetl"
   print(s[:-2])


Пример.
'''''''

Написати Пајтон функцију ``prebroj_podstr(p, s)`` која утврђује колико пута се стринг ``p`` јавља као подстринг стринга ``s``.

.. activecode:: primer3-12
   :includesrc: _src/P03/Prebroj_podstr.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Prebroj_podstr.py`` и изврши га.


Пример.
'''''''

У сваком рачунарском систему се подаци пакују у *фајлове* (или *датотеке*) и од самих почетака рачунарске ере постоји обичај
да се име фајла организује тако да последњих неколико симбола у имену фајла означава тип података који је у том фајлу похрањен.
Тај део имена фајла се обично одвоји тачком од остатка имена фајла и зове се *екстензија*. Рецимо:

.. csv-table:: Екстензије и типови података
   :header: "Екстензија", "Тип података"
   :align: left

   ".txt", "текстуална датотека"
   ".log", "текстуална датотека"
   ".png", "слика              "
   ".jpg", "слика              "
   ".bmp", "слика              "
   ".mpg", "видео              "
   ".mp3", "звук               "

Написати Пајтон програм који од корисника учитава име фајла и на основу горње табеле одређује тип
података који је у њему похрањен. У случају да се екстензија имена фајла не налази у овој табели
програм треба да пријави да се ради о непознатом типу података.

.. activecode:: primer3-13
   :includesrc: _src/P03/Ekstenzije.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Ekstenzije.py`` и изврши га.

   Ево и кратке видео демонстрације:
   
   .. ytpopup:: KgoFGIL_gVI
      :width: 735
      :height: 415
      :align: center

Пример.
'''''''

Написати Пајтон функцију ``broj_reci(s)`` која у датом стрингу броји речи. Реч је непрекидан низ слова.

.. activecode:: primer3-14
   :includesrc: _src/P03/Broj_reci.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Broj_reci.py`` и изврши га.



Операције са стринговима
------------------------

У Пајтону, као и у већини модерних програмских језика, стрингови су *непроменљиви* (то својство се на енглеском зове
*immutability*). На пример, нека је

.. code-block:: python

   s = "Banana"

Ако покушамо да променимо прво слово стринга на мало слово 'b' добићемо грешку!

.. code-block:: python

   s[0] = "b"
   # ОВО НЕ МОЖЕ! СИСТЕМ ЋЕ ПРИЈАВИТИ ГРЕШКУ!

Зато се трансформације стрингова увек своде на то да се од старог стринга изгради нови стринг који има својства која желимо.
Једна од основних операција коју при томе користимо је *надовезивање стрингова* или *конкатенација*.
Операција надовезивања стрингова се означава знаком `+`. На пример:

.. activecode:: primer3-15

   s = "Novi"
   t = "Beograd"
   print(s + t)

Важно је напоменути да се стрингови надовезују на најједноставнији могући начин: просто се дода један стринг на крај
оног другог, без уметања празнина или неке друге врсте мудровања.

Користећи операцију надовезивања можемо стрингу додати неки други стринг на почетак или на крај. На пример:

.. activecode:: primer3-16

   s = "bana"
   s = "opro" + s
   print(s)

   t = "bana"
   t = t + "na"
   print(t)

Још једна интересантна операција је множење стринга бројем:

.. activecode:: primer3-17

   print("Mir! " * 3)

Пример.
'''''''

Ђоле треба 100 пута (за казну :-)) да испише реченицу "Ученици не смеју да се гађају кредом!". Помозите Ђолету!

.. activecode:: primer3-18

   print("Ученици не смеју да се гађају кредом! " * 100)

Пример.
'''''''

Написати Пајтон функцију која обрће стринг.

.. activecode:: primer3-19
   :includesrc: _src/P03/Obrni_string.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Obrni_string.py`` и изврши га.

Ова функција од стринга ``s`` у променљивој ``novi`` изгради нови стринг који садржи иста слова као и стринг ``s``,
али у обрнутом редоследу. На почетку поставимо стринг ``novi`` на празан стринг. Потом у циклусу слова стринга
``s`` додајемо на стринг ``novi``, али једно по једно на почетак стринга ``novi``.
Тако прво слово стринга ``s`` постаје последње слово стринга ``novi``, док последње слово стринга ``s``
на крају буде прво слово стринга ``novi``. Тако у стрингу ``novi`` изградимо слово по слово обрнуту верзију
стринга ``s``.

Пример.
'''''''

Написати Пајтон програм који проверава да ли је дата реченица палиндром.
Приликом провере треба игнорисати празинине и величину слова. На пример, следеће реченице су палиндроми:

.. code-block:: text

   Ана воли Милована!
   Сир има мирис?
   Сава зидар ради за вас
   Маја са Недом оде на сајам.

*Решење.* У решењу овог примера ћемо користити уграђену функцију ``isaplha()``
која проверава да ли је нешто слово, као и уграђену функцију ``lower()`` која од стринга прави нови у коме су сва слова мала.

.. activecode:: primer3-20
   :includesrc: _src/P03/Palindrom.py

.. infonote::

   Изврши исти програм и у Пајтон окружењу!
   
   Покрени IDLE, из фолдера ``P03`` учитај програм ``Palindrom.py`` и изврши га.

   Ево и кратке видео демонстрације:
   
   .. ytpopup:: 17srK5-x7NI
      :width: 735
      :height: 415
      :align: center

Задаци
------

Задатак 1.
''''''''''''''''''''''

Написати Пајтон функцију ``broj_samoglasnika(s)`` која
утврђује број самогласника у стрингу ``s``. Претпостављамо да ``s`` садржи реченицу
српског језика, па треба пребројати само самогласнике који се јављају у српском (а, е, и, о, у),
*независно од тога да ли је реченица написана ћирилицом или латиницом!*
(Водити рачуна о великим и малим словима!)

.. activecode:: zadatak3-1
   :runortest: test1, test2, test3, test4
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-
   def broj_samoglasnika(s):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = broj_samoglasnika("Ovde ima mnogo samoglasnika")
   test2 = broj_samoglasnika("Led je čvrst, krt i tvrd.")
   test3 = broj_samoglasnika("Čvrst, krt, tvrd zvrk!")
   test4 = broj_samoglasnika("")
   # -*- acsection: after-main -*-
   print(test1, test2, test3, test4)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           def __samogl(c):
               return c.lower() in ["a", "e", "i", "o", "u", "а", "е", "и", "о", "у"]
           def __brsam(s):
               n=0
               for c in s:
                   if __samogl(c): n += 1
               return n
           rez1 = __brsam("Ovde ima mnogo samoglasnika")
           rez2 = __brsam("Led je čvrst, krt i tvrd.")
           rez3 = __brsam("Čvrst, krt, tvrd zvrk!")
           rez4 = __brsam("")
           run_test = acMainSection(test1=test1,test2=test2,test3=test3,test4=test4)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде %s" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде %s" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде %s" % rez3)
           self.assertEqual(run_test["test4"], rez4, "Вредност променљиве 'test4' треба да буде %s" % rez4)
   myTests().main()

Задатак 2.
''''''''''''''''''''''

Написати Пајтон функцију ``broj_suglasnika(s)`` која
утврђује број сугласника у стрингу ``s``. Претпостављамо да ``s`` садржи реченицу
српског језика, па је сугласник свако слово које је различито од а, е, и, о, у
*независно од тога да ли је реченица написана ћирилицом или латиницом!*
(Водити рачуна о великим и малим словима!)

.. activecode:: zadatak3-1b
   :runortest: test1, test2, test3, test4
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-
   def broj_suglasnika(s):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = broj_suglasnika("Ovde ima mnogo samoglasnika")
   test2 = broj_suglasnika("Led je čvrst, krt i tvrd.")
   test3 = broj_suglasnika("Čvrst, krt, tvrd zvrk!")
   test4 = broj_suglasnika("")
   # -*- acsection: after-main -*-
   print(test1, test2, test3, test4)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           def __samogl(c):
               return c.lower() in ["a", "e", "i", "o", "u", "а", "е", "и", "о", "у"]
           def __sugl(c):
               return c.isalpha() and not __samogl(c)
           def __brsug(s):
               n=0
               for c in s:
                   if __sugl(c): n += 1
               return n
           rez1 = __brsug("Ovde ima mnogo samoglasnika")
           rez2 = __brsug("Led je čvrst, krt i tvrd.")
           rez3 = __brsug("Čvrst, krt, tvrd zvrk!")
           rez4 = __brsug("")
           run_test = acMainSection(test1=test1,test2=test2,test3=test3,test4=test4)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде %s" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде %s" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде %s" % rez3)
           self.assertEqual(run_test["test4"], rez4, "Вредност променљиве 'test4' треба да буде %s" % rez4)
   myTests().main()



Задатак 3.
''''''''''''''''''''''

Написати Пајтон функцију ``poslednja_rec(s)`` која из датог стринга издваја последњу реч која је
наведена у стрингу. Ако у стрингу не постоји ниједно слово функција треба да врати празан стринг.
(Напомена: реч је непрекидан низ слова.)

.. activecode:: zadatak3-2
   :runortest: test1, test2, test3, test4
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-
   def poslednja_rec(s):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = poslednja_rec("Ovaj string ima pet reci")
   test2 = poslednja_rec("Ovaj string se zavrsava uzvicnicima!!!")
   test3 = poslednja_rec("Test")
   test4 = poslednja_rec("1 2 3 4 5")
   # -*- acsection: after-main -*-
   print(test1, test2, test3, test4)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           rez1 = "reci"
           rez2 = "uzvicnicima"
           rez3 = "Test"
           rez4 = ""
           run_test = acMainSection(test1=test1,test2=test2,test3=test3,test4=test4)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде 'reci'")
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде 'uzvicnicima'")
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде 'Test'")
           self.assertEqual(run_test["test4"], rez4, "Вредност променљиве 'test4' треба да буде празан стринг")
   myTests().main()


Задатак 4*.
''''''''''''''''''''''

Написати Пајтон функцију ``obrni_reci(s)`` која од датог стринга прави нови у коме су речи
послагане од последње према првој. На пример, за стринг

.. code-block:: python

    "Napisati program koji ispisuje reci unetog teksta u obrnutom poretku"

функција треба да врати:

.. code-block:: python

    "poretku obrnutom u teksta unetog reci ispisuje koji program Napisati"

.. activecode:: zadatak3-3
   :runortest: test1, test2, test3
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-

   def obrni_reci(s):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = obrni_reci("Dve reci")
   test2 = obrni_reci("Ovaj string se ne zavrsava uzvicnikom")
   test3 = obrni_reci("Test")
   # -*- acsection: after-main -*-
   
   print(test1)
   print(test2)
   print(test3)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           def __obrnir(s):
              s += " "
              t = ""
              w = ""
              for i in range(len(s)-1):
                  if s[i].isalpha():
                      w += s[i]
                      if not(s[i+1].isalpha()):
                          if t == "":
                              t = w
                          else:
                              t = w + " " + t
                          w = ""
              return t
           rez1 = __obrnir("Dve reci")
           rez2 = __obrnir("Ovaj string se ne zavrsava uzvicnikom")
           rez3 = __obrnir("Test")
           run_test = acMainSection(test1=test1,test2=test2,test3=test3)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде '%s'" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде '%s'" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде '%s'" % rez3)
   myTests().main()





Задатак 5*.
''''''''''''''''''''''

Написати Пајтон функцију која проверава да ли су у датом стрингу заграде ``(`` и ``)`` *балансиране*.
То значи да:

1. у стрингу имамо исти број отворених и затоврених заграда, и
2. не постоји почетни сегмент стринга у коме је број затворених заграда већи од броја отворених.

.. activecode:: zadatak3-4
   :runortest: test1, test2, test3, test4, test5
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-
   def balansirane_zagrade(s):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = balansirane_zagrade("()") # јесу
   test2 = balansirane_zagrade("(())") # јесу
   test3 = balansirane_zagrade("(())(()(()()))") # јесу
   test4 = balansirane_zagrade(")(") # нису
   test5 = balansirane_zagrade("(()))(") # нису
   # -*- acsection: after-main -*-
   print(test1, test2, test3, test4, test5)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           rez1 = True
           rez2 = True
           rez3 = True
           rez4 = False
           rez5 = False
           run_test = acMainSection(test1=test1,test2=test2,test3=test3,test4=test4,test5=test5)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде %s" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде %s" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде %s" % rez3)
           self.assertEqual(run_test["test4"], rez4, "Вредност променљиве 'test4' треба да буде %s" % rez4)
           self.assertEqual(run_test["test5"], rez5, "Вредност променљиве 'test5' треба да буде %s" % rez5)
   myTests().main()








Задатак 6.
''''''''''''''''''''''

Написати Пајтон функцију ``razmeni(s, din_za_1_eur)`` која конвертује дати износ из динара у евре и обрнуто.
Стринг ``s`` садржи износ записан у облику ``број валута`` на пример овако:

.. code-block:: python

    "125 DIN"
    "217.50 EUR"
    "1527.99 DIN"
    "50 EUR"

док аргумент ``din_za_1_eur`` представља вредност једног евра у динарима.
Функција треба да врати стринг који има облик ``број валута``. При томе користи бити уграђене функције ``float`` и ``str``.
(За неки стринг ``p`` функција ``float(p)`` враћа број који је записан стрингом ``p`` игноришући при том празнине које се
можда јављају у стрингу; с друге стране, функција ``str`` од неког броја прави стринг који садржи његов запис.)

*Добијене износе НЕ ТРЕБА заокруживати на две децимале!*

Функција ``razmeni`` треба да ради овако:

.. code-block:: python

   >>> razmeni("124.99 EUR", 117.90)
   '14736.321‬ DIN'

   >>> razmeni("12000 DIN", 117.90)
   ‭'101.7811704 EUR'

Ако корисник унесе неку трећу валуту, програм треба да врати стринг "?VALUTA":

.. code-block:: python

   >>> razmeni("124.99 USD", 117.90)
   '?VALUTA'


.. activecode:: zadatak3-5
   :runortest: test1, test2, test3, test4
   :nocodelens:

   # -*- acsection: general-init -*-
   # -*- acsection: main -*-

   def razmeni(s, din_za_1_eur):
       # Овде напиши функцију
       return -1234  # поправи овај ред!

   # Провера
   test1 = razmeni("1 EUR", 117.90)
   test2 = razmeni("124.99 EUR", 117.90)
   test3 = razmeni("12000 DIN", 117.90)
   test4 = razmeni("1 USD", 107.90)
   # -*- acsection: after-main -*-
   
   print(test1)
   print(test2)
   print(test3)
   print(test4)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
           def __razmeni(s, dz1e):
               x = s.split()
               iznos = float(x[0])
               valuta = x[1]
               if valuta.upper() == "DIN": return str(iznos/dz1e) + " EUR"
               if valuta.upper() == "EUR": return str(iznos * dz1e) + " DIN"
               return "?VALUTA"
           rez1 = __razmeni("1 EUR", 117.90)
           rez2 = __razmeni("124.99 EUR", 117.90)
           rez3 = __razmeni("12000 DIN", 117.90)
           rez4 = __razmeni("1 USD", 107.90)
           run_test = acMainSection(test1=test1,test2=test2,test3=test3,test4=test4)
           self.assertEqual(run_test["test1"], rez1, "Вредност променљиве 'test1' треба да буде '%s'" % rez1)
           self.assertEqual(run_test["test2"], rez2, "Вредност променљиве 'test2' треба да буде '%s'" % rez2)
           self.assertEqual(run_test["test3"], rez3, "Вредност променљиве 'test3' треба да буде '%s'" % rez3)
           self.assertEqual(run_test["test4"], rez4, "Вредност променљиве 'test4' треба да буде '%s'" % rez4)
   myTests().main()



Задаци из Алгоритамске збирке задатака
----------------------------------------------

Решавањем следећих задатака можете да увежбате додатне вештине у раду са стринговима. 

https://petlja.org/biblioteka/r/problemi/Zbirka/prezime_pa_ime

https://petlja.org/biblioteka/r/problemi/Zbirka/da_li_je_podniska

https://petlja.org/biblioteka/r/problemi/Zbirka/izbacivanje_podniski

https://petlja.org/biblioteka/r/problemi/Zbirka/rec_frankenstajn

https://petlja.org/biblioteka/r/problemi/Zbirka/cezarov_kod

https://petlja.org/biblioteka/r/problemi/Zbirka/vrednost_izraza

https://petlja.org/biblioteka/r/problemi/Zbirka/spreadsheet_kolone

https://petlja.org/biblioteka/r/problemi/Zbirka/brojevne_osnove

https://petlja.org/biblioteka/r/problemi/Zbirka/arapski_u_rimski

https://petlja.org/biblioteka/r/problemi/Zbirka/rimski_u_arapski





